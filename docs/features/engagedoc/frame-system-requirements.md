# Frame System Requirements - EngageDoc-Studio v209

## 1. 概要

Frame System（フレームシステム）は、EngageDoc-Studioの中核機能であり、複数のドキュメントフレームを統合的に管理・表示するシステムです。v208で実装されたNative Format対応とUnified UI Designを基盤とし、v209では更なる機能拡張を予定しています。

## 2. フレームシステム要件

### 2.1 基本概念

#### フレーム定義
```yaml
Frame:
  id: string          # 一意識別子
  name: string        # 表示名
  type: string        # フレームタイプ (pdf, image, svg, egdc)
  source: string      # ソースファイルパス
  metadata:
    width: number     # 幅 (px)
    height: number    # 高さ (px)
    pageCount: number # ページ数（該当する場合）
    lastModified: datetime
  transform:
    x: number         # X座標オフセット
    y: number         # Y座標オフセット
    scale: number     # スケール倍率
    rotation: number  # 回転角度（度）
  visibility:
    visible: boolean  # 表示/非表示
    opacity: number   # 不透明度 (0.0-1.0)
  navigation:
    currentPage: number
    bookmarks: array
```\n\n#### フレーム階層構造\n```\nFrameContainer\n├── FrameGroup (optional)\n│   ├── Frame1\n│   ├── Frame2\n│   └── FrameGroup (nested)\n│       ├── Frame3\n│       └── Frame4\n└── Frame5 (standalone)\n```\n\n### 2.2 機能要件\n\n#### FR-001: フレーム作成・管理\n- **要件**: 新規フレームの作成、既存フレームの編集・削除\n- **詳細**:\n  - ファイルドラッグ&ドロップによるフレーム自動作成\n  - フレーム名の変更・重複チェック\n  - フレームタイプの自動判定\n  - メタデータの自動抽出・更新\n- **優先度**: 高\n- **受入基準**:\n  - [ ] 対応形式ファイルからフレーム作成が可能\n  - [ ] フレーム名の重複回避機能\n  - [ ] メタデータ自動更新（ファイル変更検出）\n\n#### FR-002: フレーム表示制御\n- **要件**: 個別フレームの表示・非表示、順序制御\n- **詳細**:\n  - レイヤー順序の変更（前面/背面移動）\n  - 表示フィルタリング（タイプ別、グループ別）\n  - 透明度調整による重ね合わせ表示\n  - フレームロック機能（編集保護）\n- **優先度**: 高\n- **受入基準**:\n  - [ ] ドラッグ&ドロップによる順序変更\n  - [ ] フィルター機能による選択表示\n  - [ ] 透明度スライダーによる調整\n\n#### FR-003: フレーム同期・連携\n- **要件**: 複数フレーム間の同期表示・連携操作\n- **詳細**:\n  - ズーム同期（複数フレームの同時ズーム）\n  - スクロール同期（位置連動）\n  - ページ同期（マルチページドキュメント）\n  - アニメーション同期（切り替え効果）\n- **優先度**: 中\n- **受入基準**:\n  - [ ] 同期グループ設定機能\n  - [ ] マスター/スレーブ関係の設定\n  - [ ] 同期状態の視覚的表示\n\n#### FR-004: フレーム変形・配置\n- **要件**: フレームの変形、配置、レイアウト制御\n- **詳細**:\n  - 移動、回転、スケール変形\n  - グリッドスナップ機能\n  - 自動配置（整列、分散）\n  - カスタムレイアウトテンプレート\n- **優先度**: 中\n- **受入基準**:\n  - [ ] マウスによる直感的変形操作\n  - [ ] 数値入力による精密設定\n  - [ ] レイアウトテンプレートの保存・適用\n\n#### FR-005: フレーム書き出し・共有\n- **要件**: フレーム内容の書き出し、共有機能\n- **詳細**:\n  - 個別フレーム・複数フレーム選択書き出し\n  - PowerPoint連携書き出し\n  - PDF統合書き出し\n  - クラウド共有（将来機能）\n- **優先度**: 中\n- **受入基準**:\n  - [ ] PowerPoint形式でのレイアウト保持書き出し\n  - [ ] 高解像度書き出しオプション\n  - [ ] バッチ書き出し機能\n\n## 3. 非機能要件\n\n### 3.1 パフォーマンス要件\n\n#### NFR-001: 描画性能\n- **要件**: 大量フレーム表示時の応答性確保\n- **詳細**:\n  - 同時表示フレーム数: 最大50フレーム\n  - 初期表示時間: 5秒以内\n  - ズーム操作レスポンス: 60FPS維持\n  - メモリ使用量: 2GB以内\n- **測定方法**: パフォーマンステストによる自動測定\n\n#### NFR-002: ファイル処理性能\n- **要件**: 大容量ファイルの効率的処理\n- **詳細**:\n  - 最大ファイルサイズ: 500MB\n  - PDF最大ページ数: 1000ページ\n  - 画像最大解像度: 8K (7680x4320)\n  - 同時読み込み: 10ファイル\n- **測定方法**: 実ファイルによる負荷テスト\n\n### 3.2 使いやすさ要件\n\n#### NFR-003: 操作性\n- **要件**: 直感的で効率的な操作環境\n- **詳細**:\n  - マウス操作のみで全機能利用可能\n  - キーボードショートカット完全対応\n  - コンテキストメニューによる機能アクセス\n  - アンドゥ/リドゥ機能（50操作まで）\n- **測定方法**: ユーザビリティテスト\n\n#### NFR-004: 学習容易性\n- **要件**: 短時間での操作習得\n- **詳細**:\n  - 初回利用時のオンボーディング\n  - ツールチップによる機能説明\n  - 操作ガイドの統合\n  - エラー時の明確なガイダンス\n- **測定方法**: 新規ユーザーによる操作習得時間測定\n\n### 3.3 可用性要件\n\n#### NFR-005: 安定性\n- **要件**: 連続動作時の安定性確保\n- **詳細**:\n  - 連続動作時間: 8時間以上\n  - メモリリーク防止\n  - 異常ファイル処理時の堅牢性\n  - 自動回復機能\n- **測定方法**: 長時間動作テスト\n\n## 4. 技術仕様\n\n### 4.1 フレーム管理アーキテクチャ\n\n```javascript\nclass FrameManager {\n  constructor() {\n    this.frames = new Map();        // フレーム管理\n    this.groups = new Map();        // グループ管理\n    this.selection = new Set();     // 選択状態\n    this.history = new History();   // 操作履歴\n    \n    this.setupEventHandlers();\n  }\n  \n  // フレーム作成\n  async createFrame(source, options = {}) {\n    const frame = new Frame({\n      id: this.generateId(),\n      source,\n      ...options\n    });\n    \n    await frame.initialize();\n    this.frames.set(frame.id, frame);\n    \n    this.emit('frame:created', frame);\n    return frame;\n  }\n  \n  // フレーム削除\n  deleteFrame(frameId) {\n    const frame = this.frames.get(frameId);\n    if (!frame) return false;\n    \n    // 依存関係チェック\n    if (this.hasDependencies(frameId)) {\n      throw new Error('Cannot delete frame with dependencies');\n    }\n    \n    frame.destroy();\n    this.frames.delete(frameId);\n    this.selection.delete(frameId);\n    \n    this.emit('frame:deleted', frameId);\n    return true;\n  }\n  \n  // フレーム更新\n  updateFrame(frameId, updates) {\n    const frame = this.frames.get(frameId);\n    if (!frame) return false;\n    \n    const oldState = frame.getState();\n    frame.update(updates);\n    \n    this.history.push({\n      type: 'frame:update',\n      frameId,\n      oldState,\n      newState: frame.getState()\n    });\n    \n    this.emit('frame:updated', frame);\n    return true;\n  }\n}\n\nclass Frame {\n  constructor(options) {\n    this.id = options.id;\n    this.name = options.name || this.generateName();\n    this.type = options.type;\n    this.source = options.source;\n    this.metadata = {};\n    this.transform = {\n      x: 0, y: 0, scale: 1, rotation: 0\n    };\n    this.visibility = {\n      visible: true, opacity: 1.0\n    };\n    this.navigation = {\n      currentPage: 1, bookmarks: []\n    };\n    \n    this.content = null;\n    this.renderer = null;\n  }\n  \n  async initialize() {\n    // メタデータ抽出\n    this.metadata = await this.extractMetadata();\n    \n    // レンダラー選択\n    this.renderer = RendererFactory.create(this.type);\n    \n    // コンテンツ読み込み\n    this.content = await this.loadContent();\n    \n    this.emit('initialized');\n  }\n  \n  async render(container) {\n    if (!this.renderer) {\n      throw new Error('Renderer not initialized');\n    }\n    \n    const element = await this.renderer.render(this.content, {\n      transform: this.transform,\n      visibility: this.visibility,\n      navigation: this.navigation\n    });\n    \n    container.appendChild(element);\n    return element;\n  }\n  \n  // 変形操作\n  setTransform(transform) {\n    this.transform = { ...this.transform, ...transform };\n    this.emit('transform:changed', this.transform);\n  }\n  \n  // 表示制御\n  setVisibility(visibility) {\n    this.visibility = { ...this.visibility, ...visibility };\n    this.emit('visibility:changed', this.visibility);\n  }\n  \n  // ナビゲーション\n  navigateToPage(page) {\n    if (page >= 1 && page <= this.metadata.pageCount) {\n      this.navigation.currentPage = page;\n      this.emit('navigation:changed', this.navigation);\n    }\n  }\n}\n```\n\n### 4.2 同期システム\n\n```javascript\nclass FrameSyncManager {\n  constructor() {\n    this.syncGroups = new Map();\n    this.syncHandlers = new Map();\n    \n    this.registerDefaultHandlers();\n  }\n  \n  createSyncGroup(groupId, options = {}) {\n    const group = new SyncGroup(groupId, {\n      type: options.type || 'transform', // transform, navigation, visibility\n      mode: options.mode || 'master-slave', // master-slave, peer-to-peer\n      delay: options.delay || 0\n    });\n    \n    this.syncGroups.set(groupId, group);\n    return group;\n  }\n  \n  addFrameToGroup(groupId, frameId, role = 'slave') {\n    const group = this.syncGroups.get(groupId);\n    if (!group) return false;\n    \n    group.addFrame(frameId, role);\n    \n    // イベントハンドラー設定\n    const frame = frameManager.getFrame(frameId);\n    const handler = this.createSyncHandler(group, frameId);\n    \n    frame.on('transform:changed', handler);\n    frame.on('navigation:changed', handler);\n    \n    return true;\n  }\n  \n  createSyncHandler(group, sourceFrameId) {\n    return (event) => {\n      if (group.isUpdating) return; // 循環参照防止\n      \n      group.isUpdating = true;\n      \n      try {\n        group.frames.forEach((frameInfo, frameId) => {\n          if (frameId === sourceFrameId) return;\n          \n          const frame = frameManager.getFrame(frameId);\n          const syncData = this.calculateSyncData(event, frameInfo.role);\n          \n          if (group.type === 'transform') {\n            frame.setTransform(syncData);\n          } else if (group.type === 'navigation') {\n            frame.setNavigation(syncData);\n          }\n        });\n      } finally {\n        setTimeout(() => {\n          group.isUpdating = false;\n        }, group.delay);\n      }\n    };\n  }\n}\n```\n\n### 4.3 レイアウトシステム\n\n```javascript\nclass LayoutManager {\n  constructor() {\n    this.templates = new Map();\n    this.constraints = new Map();\n    \n    this.loadDefaultTemplates();\n  }\n  \n  // レイアウトテンプレート適用\n  applyTemplate(templateName, frames) {\n    const template = this.templates.get(templateName);\n    if (!template) throw new Error(`Template not found: ${templateName}`);\n    \n    frames.forEach((frame, index) => {\n      const position = template.calculatePosition(index, frames.length);\n      frame.setTransform({\n        x: position.x,\n        y: position.y,\n        scale: position.scale || 1\n      });\n    });\n  }\n  \n  // 自動配置\n  autoArrange(frames, type = 'grid') {\n    switch (type) {\n      case 'grid':\n        this.arrangeGrid(frames);\n        break;\n      case 'cascade':\n        this.arrangeCascade(frames);\n        break;\n      case 'tile':\n        this.arrangeTile(frames);\n        break;\n    }\n  }\n  \n  arrangeGrid(frames) {\n    const cols = Math.ceil(Math.sqrt(frames.length));\n    const rows = Math.ceil(frames.length / cols);\n    \n    const containerWidth = 800; // 仮の値\n    const containerHeight = 600;\n    const cellWidth = containerWidth / cols;\n    const cellHeight = containerHeight / rows;\n    \n    frames.forEach((frame, index) => {\n      const col = index % cols;\n      const row = Math.floor(index / cols);\n      \n      frame.setTransform({\n        x: col * cellWidth,\n        y: row * cellHeight,\n        scale: Math.min(\n          cellWidth / frame.metadata.width,\n          cellHeight / frame.metadata.height\n        ) * 0.9 // パディング考慮\n      });\n    });\n  }\n}\n```\n\n## 5. データフォーマット\n\n### 5.1 フレーム設定ファイル (.frameconfig)\n\n```json\n{\n  \"version\": \"1.0\",\n  \"frames\": [\n    {\n      \"id\": \"frame_001\",\n      \"name\": \"Technical Drawing\",\n      \"type\": \"pdf\",\n      \"source\": \"./documents/technical_drawing.pdf\",\n      \"metadata\": {\n        \"width\": 1920,\n        \"height\": 1080,\n        \"pageCount\": 15,\n        \"fileSize\": 2048576,\n        \"lastModified\": \"2025-08-12T10:30:00Z\"\n      },\n      \"transform\": {\n        \"x\": 100,\n        \"y\": 100,\n        \"scale\": 1.0,\n        \"rotation\": 0\n      },\n      \"visibility\": {\n        \"visible\": true,\n        \"opacity\": 1.0,\n        \"zIndex\": 1\n      },\n      \"navigation\": {\n        \"currentPage\": 1,\n        \"bookmarks\": [\n          { \"page\": 1, \"title\": \"Overview\" },\n          { \"page\": 5, \"title\": \"Details\" }\n        ]\n      },\n      \"annotations\": [\n        {\n          \"type\": \"highlight\",\n          \"page\": 1,\n          \"bounds\": { \"x\": 100, \"y\": 200, \"width\": 300, \"height\": 50 },\n          \"color\": \"#ffff00\",\n          \"text\": \"Important section\"\n        }\n      ]\n    }\n  ],\n  \"groups\": [\n    {\n      \"id\": \"group_001\",\n      \"name\": \"Main Documents\",\n      \"frameIds\": [\"frame_001\"],\n      \"syncSettings\": {\n        \"type\": \"transform\",\n        \"enabled\": true\n      }\n    }\n  ],\n  \"layout\": {\n    \"template\": \"grid\",\n    \"parameters\": {\n      \"columns\": 2,\n      \"rows\": 2,\n      \"spacing\": 20\n    }\n  }\n}\n```\n\n### 5.2 書き出し設定\n\n```json\n{\n  \"export\": {\n    \"format\": \"pptx\",\n    \"options\": {\n      \"slideSize\": \"A4\",\n      \"resolution\": 300,\n      \"embedFonts\": true,\n      \"includeAnnotations\": true,\n      \"preserveLinks\": true\n    },\n    \"frames\": [\n      {\n        \"frameId\": \"frame_001\",\n        \"pages\": [1, 3, 5],\n        \"position\": { \"x\": 0, \"y\": 0 },\n        \"size\": { \"width\": \"100%\", \"height\": \"auto\" }\n      }\n    ]\n  }\n}\n```\n\n## 6. テスト仕様\n\n### 6.1 単体テスト\n\n```javascript\ndescribe('Frame Management', () => {\n  let frameManager;\n  \n  beforeEach(() => {\n    frameManager = new FrameManager();\n  });\n  \n  test('should create frame from PDF file', async () => {\n    const source = './test/sample.pdf';\n    const frame = await frameManager.createFrame(source);\n    \n    expect(frame.id).toBeDefined();\n    expect(frame.type).toBe('pdf');\n    expect(frame.metadata.pageCount).toBeGreaterThan(0);\n  });\n  \n  test('should update frame transform', () => {\n    const frame = new Frame({ id: 'test', type: 'image' });\n    const newTransform = { x: 100, y: 200, scale: 1.5 };\n    \n    frame.setTransform(newTransform);\n    \n    expect(frame.transform.x).toBe(100);\n    expect(frame.transform.y).toBe(200);\n    expect(frame.transform.scale).toBe(1.5);\n  });\n  \n  test('should sync frames in group', () => {\n    const syncManager = new FrameSyncManager();\n    const groupId = 'sync_group_1';\n    \n    syncManager.createSyncGroup(groupId, { type: 'transform' });\n    syncManager.addFrameToGroup(groupId, 'frame1', 'master');\n    syncManager.addFrameToGroup(groupId, 'frame2', 'slave');\n    \n    const masterFrame = frameManager.getFrame('frame1');\n    const slaveFrame = frameManager.getFrame('frame2');\n    \n    masterFrame.setTransform({ x: 100, y: 100 });\n    \n    expect(slaveFrame.transform.x).toBe(100);\n    expect(slaveFrame.transform.y).toBe(100);\n  });\n});\n```\n\n### 6.2 統合テスト\n\n```javascript\ndescribe('Frame System Integration', () => {\n  test('should handle large PDF file', async () => {\n    const largePDF = './test/large_document.pdf'; // 100MB+\n    const startTime = Date.now();\n    \n    const frame = await frameManager.createFrame(largePDF);\n    const loadTime = Date.now() - startTime;\n    \n    expect(loadTime).toBeLessThan(5000); // 5秒以内\n    expect(frame.metadata.pageCount).toBeGreaterThan(0);\n  });\n  \n  test('should maintain performance with multiple frames', async () => {\n    const frames = [];\n    \n    // 20フレーム作成\n    for (let i = 0; i < 20; i++) {\n      const frame = await frameManager.createFrame(`./test/doc${i}.pdf`);\n      frames.push(frame);\n    }\n    \n    const renderStart = Date.now();\n    await Promise.all(frames.map(frame => frame.render(document.body)));\n    const renderTime = Date.now() - renderStart;\n    \n    expect(renderTime).toBeLessThan(3000); // 3秒以内\n  });\n});\n```\n\n## 7. 受入テスト基準\n\n### 7.1 機能受入基準\n- [ ] PDFファイルからフレーム作成が3秒以内に完了する\n- [ ] 画像ファイル（最大50MB）からフレーム作成が1秒以内に完了する\n- [ ] 20フレーム同時表示時のズーム操作が滑らかに動作する（60FPS維持）\n- [ ] フレーム変形操作のアンドゥ/リドゥが正常に動作する\n- [ ] PowerPoint書き出しでレイアウトが正確に保持される\n\n### 7.2 性能受入基準\n- [ ] メモリ使用量が2GB以下を維持する\n- [ ] 8時間連続動作でメモリリークが発生しない\n- [ ] 異常ファイル読み込み時にアプリケーションがクラッシュしない\n- [ ] ネットワークドライブ上のファイルも正常に処理される\n\n### 7.3 ユーザビリティ受入基準\n- [ ] 初回利用者が基本操作を10分以内に習得できる\n- [ ] キーボードショートカットで全ての主要機能にアクセスできる\n- [ ] エラー発生時に明確なメッセージと対処方法が表示される\n- [ ] オンラインヘルプが統合されている\n\n---\n\n**要件仕様管理**: Media Viewer Development Team  \n**最終更新**: 2025-08-12  \n**要件バージョン**: v208基盤 → v209拡張予定