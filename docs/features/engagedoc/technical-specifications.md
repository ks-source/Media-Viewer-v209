# EngageDoc-Studio 技術仕様書

## 1. システム概要

EngageDoc-Studioは、Electronベースのクロスプラットフォーム・ドキュメント表示編集アプリケーションです。v208で実装された高度な機能群を基に、フレームベース編集、D3ズーム統合、両側コントロールパネルを核とした統合開発環境を提供します。

## 2. アーキテクチャ仕様

### 2.1 プラットフォーム要件
- **Node.js**: 16.x 以上
- **Electron**: 20.x 以上  
- **対応OS**: Windows 10+, macOS 10.15+, Linux (Ubuntu 20.04+)
- **メモリ**: 最小 4GB、推奨 8GB以上
- **ストレージ**: 最小 500MB の空き容量

### 2.2 依存関係
```json
{
  "dependencies": {
    "electron": "^20.3.0",
    "d3": "^7.8.0",
    "pdfjs-dist": "^3.8.0",
    "sharp": "^0.32.0",
    "jszip": "^3.10.0"
  },
  "devDependencies": {
    "electron-builder": "^24.0.0",
    "jest": "^29.0.0",
    "eslint": "^8.0.0"
  }
}\n```\n\n## 3. モジュール構成\n\n### 3.1 EngageDoc-Reader Core\n```\nEngageDoc-Reader/\n├── src/\n│   ├── main.js              # Electronメインプロセス\n│   ├── preload.js           # セキュリティブリッジ\n│   ├── viewer.html          # メインUI HTML\n│   ├── viewer.js            # メインアプリケーションロジック\n│   └── viewer.css           # UIスタイル定義\n│\n├── modules/\n│   ├── d3-integration.js    # D3.js統合システム\n│   ├── content-renderer.js  # コンテンツレンダリング\n│   ├── panel-manager.js     # パネル管理システム\n│   ├── file-handler.js      # ファイル操作\n│   └── state-manager.js     # アプリケーション状態管理\n│\n├── renderers/\n│   ├── pdf-renderer.js      # PDFレンダリング\n│   ├── image-renderer.js    # 画像レンダリング\n│   ├── svg-renderer.js      # SVGレンダリング\n│   ├── end-renderer.js      # END形式レンダリング（Frame Sheets統合）
│   └── ends-renderer.js     # ENDS形式レンダリング\n│\n└── utils/\n    ├── logger.js            # ログシステム\n    ├── config.js            # 設定管理\n    └── helpers.js           # ユーティリティ関数\n```\n\n### 3.2 メインプロセス (main.js)\n```javascript\nconst { app, BrowserWindow, ipcMain, dialog } = require('electron');\nconst path = require('path');\nconst fs = require('fs').promises;\n\nclass EngageDocStudio {\n  constructor() {\n    this.mainWindow = null;\n    this.config = new Config();\n    this.setupApplication();\n  }\n  \n  setupApplication() {\n    app.whenReady().then(() => {\n      this.createMainWindow();\n      this.setupIPC();\n      this.setupApplicationMenu();\n    });\n    \n    app.on('window-all-closed', () => {\n      if (process.platform !== 'darwin') {\n        app.quit();\n      }\n    });\n  }\n  \n  createMainWindow() {\n    this.mainWindow = new BrowserWindow({\n      width: this.config.get('window.width', 1400),\n      height: this.config.get('window.height', 900),\n      minWidth: 1000,\n      minHeight: 700,\n      webPreferences: {\n        nodeIntegration: false,\n        contextIsolation: true,\n        enableRemoteModule: false,\n        preload: path.join(__dirname, 'preload.js'),\n        sandbox: false\n      },\n      titleBarStyle: 'hiddenInset',\n      show: false\n    });\n    \n    this.mainWindow.loadFile('src/viewer.html');\n    \n    // グレースフル表示\n    this.mainWindow.once('ready-to-show', () => {\n      this.mainWindow.show();\n    });\n  }\n  \n  setupIPC() {\n    // ファイル操作\n    ipcMain.handle('file:open', this.handleFileOpen.bind(this));\n    ipcMain.handle('file:save', this.handleFileSave.bind(this));\n    ipcMain.handle('file:export', this.handleFileExport.bind(this));\n    \n    // ウィンドウ制御\n    ipcMain.handle('window:minimize', () => this.mainWindow.minimize());\n    ipcMain.handle('window:maximize', () => {\n      if (this.mainWindow.isMaximized()) {\n        this.mainWindow.unmaximize();\n      } else {\n        this.mainWindow.maximize();\n      }\n    });\n    \n    // アプリケーション制御\n    ipcMain.handle('app:getVersion', () => app.getVersion());\n    ipcMain.handle('app:quit', () => app.quit());\n  }\n  \n  async handleFileOpen(event, options = {}) {\n    const result = await dialog.showOpenDialog(this.mainWindow, {\n      properties: ['openFile'],\n      filters: [\n        {\n          name: 'All Supported Files',\n          extensions: ['pdf', 'png', 'jpg', 'jpeg', 'svg', 'egdc']\n        },\n        { name: 'PDF Files', extensions: ['pdf'] },\n        { name: 'Image Files', extensions: ['png', 'jpg', 'jpeg'] },\n        { name: 'Vector Files', extensions: ['svg'] },\n        { name: 'EGDC Files', extensions: ['egdc'] }\n      ],\n      ...options\n    });\n    \n    if (!result.canceled && result.filePaths.length > 0) {\n      const filePath = result.filePaths[0];\n      const content = await this.loadFileContent(filePath);\n      return { success: true, filePath, content };\n    }\n    \n    return { success: false };\n  }\n  \n  async loadFileContent(filePath) {\n    const ext = path.extname(filePath).toLowerCase();\n    const stats = await fs.stat(filePath);\n    \n    return {\n      path: filePath,\n      name: path.basename(filePath),\n      extension: ext,\n      size: stats.size,\n      lastModified: stats.mtime,\n      data: await fs.readFile(filePath)\n    };\n  }\n}\n\n// アプリケーション起動\nconst engageDoc = new EngageDocStudio();\n```\n\n### 3.3 セキュリティブリッジ (preload.js)\n```javascript\nconst { contextBridge, ipcRenderer } = require('electron');\n\n// 安全なAPI露出\ncontextBridge.exposeInMainWorld('electronAPI', {\n  // ファイル操作\n  openFile: (options) => ipcRenderer.invoke('file:open', options),\n  saveFile: (data, options) => ipcRenderer.invoke('file:save', data, options),\n  exportFile: (data, format) => ipcRenderer.invoke('file:export', data, format),\n  \n  // ウィンドウ制御\n  minimizeWindow: () => ipcRenderer.invoke('window:minimize'),\n  maximizeWindow: () => ipcRenderer.invoke('window:maximize'),\n  closeWindow: () => ipcRenderer.invoke('window:close'),\n  \n  // アプリケーション情報\n  getVersion: () => ipcRenderer.invoke('app:getVersion'),\n  quitApp: () => ipcRenderer.invoke('app:quit'),\n  \n  // イベントリスナー\n  onFileDropped: (callback) => {\n    ipcRenderer.on('file:dropped', (event, files) => callback(files));\n  },\n  \n  onWindowResize: (callback) => {\n    ipcRenderer.on('window:resize', (event, size) => callback(size));\n  }\n});\n```\n\n## 4. D3ズーム統合システム\n\n### 4.1 D3統合コア (d3-integration.js)\n```javascript\nclass D3ZoomIntegration {\n  constructor(container, options = {}) {\n    this.container = d3.select(container);\n    this.options = {\n      scaleExtent: [0.1, 10],\n      translateExtent: [[-Infinity, -Infinity], [Infinity, Infinity]],\n      enableWheel: true,\n      enableDrag: true,\n      enableDoubleClick: true,\n      ...options\n    };\n    \n    this.transform = d3.zoomIdentity;\n    this.callbacks = new Map();\n    \n    this.setupZoom();\n  }\n  \n  setupZoom() {\n    this.zoom = d3.zoom()\n      .scaleExtent(this.options.scaleExtent)\n      .translateExtent(this.options.translateExtent)\n      .on('zoom', this.handleZoom.bind(this))\n      .on('start', this.handleZoomStart.bind(this))\n      .on('end', this.handleZoomEnd.bind(this));\n    \n    // フィルター設定\n    this.zoom.filter((event) => {\n      if (event.type === 'wheel' && !this.options.enableWheel) return false;\n      if (event.type === 'mousedown' && !this.options.enableDrag) return false;\n      if (event.type === 'dblclick' && !this.options.enableDoubleClick) return false;\n      \n      // Ctrl+Wheel でのズーム\n      if (event.type === 'wheel') {\n        return event.ctrlKey || event.metaKey;\n      }\n      \n      return true;\n    });\n    \n    this.container.call(this.zoom);\n  }\n  \n  handleZoom(event) {\n    this.transform = event.transform;\n    \n    // コンテンツ変形適用\n    this.container.select('.zoom-content')\n      .attr('transform', this.transform);\n    \n    // コールバック実行\n    this.emit('zoom', {\n      transform: this.transform,\n      scale: this.transform.k,\n      translate: [this.transform.x, this.transform.y]\n    });\n  }\n  \n  handleZoomStart(event) {\n    this.emit('zoom:start', { transform: this.transform });\n  }\n  \n  handleZoomEnd(event) {\n    this.emit('zoom:end', { transform: this.transform });\n  }\n  \n  // プログラマティックズーム制御\n  zoomTo(scale, center = null, duration = 750) {\n    const t = d3.transition().duration(duration);\n    \n    if (center) {\n      this.container.transition(t)\n        .call(this.zoom.scaleTo, scale, center);\n    } else {\n      this.container.transition(t)\n        .call(this.zoom.scaleTo, scale);\n    }\n  }\n  \n  resetZoom(duration = 750) {\n    const t = d3.transition().duration(duration);\n    this.container.transition(t)\n      .call(this.zoom.transform, d3.zoomIdentity);\n  }\n  \n  fitContent(bounds, padding = 20, duration = 750) {\n    const containerBounds = this.container.node().getBoundingClientRect();\n    const scale = Math.min(\n      (containerBounds.width - padding * 2) / bounds.width,\n      (containerBounds.height - padding * 2) / bounds.height\n    );\n    \n    const centerX = containerBounds.width / 2;\n    const centerY = containerBounds.height / 2;\n    const x = centerX - (bounds.x + bounds.width / 2) * scale;\n    const y = centerY - (bounds.y + bounds.height / 2) * scale;\n    \n    const transform = d3.zoomIdentity.translate(x, y).scale(scale);\n    \n    const t = d3.transition().duration(duration);\n    this.container.transition(t)\n      .call(this.zoom.transform, transform);\n  }\n  \n  // イベントシステム\n  on(event, callback) {\n    if (!this.callbacks.has(event)) {\n      this.callbacks.set(event, new Set());\n    }\n    this.callbacks.get(event).add(callback);\n  }\n  \n  off(event, callback) {\n    if (this.callbacks.has(event)) {\n      this.callbacks.get(event).delete(callback);\n    }\n  }\n  \n  emit(event, data) {\n    if (this.callbacks.has(event)) {\n      this.callbacks.get(event).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in ${event} callback:`, error);\n        }\n      });\n    }\n  }\n}\n\n// エクスポート\nwindow.D3ZoomIntegration = D3ZoomIntegration;\n```\n\n### 4.2 コンテンツレンダリングシステム\n```javascript\nclass ContentRenderer {\n  constructor() {\n    this.renderers = new Map();\n    this.cache = new Map();\n    this.loadingTasks = new Map();\n    \n    this.registerDefaultRenderers();\n  }\n  \n  registerDefaultRenderers() {\n    this.register('pdf', new PDFRenderer());\n    this.register('image', new ImageRenderer());\n    this.register('svg', new SVGRenderer());\n    this.register('end', new ENDRenderer());
    this.register('ends', new ENDSRenderer());\n  }\n  \n  register(type, renderer) {\n    this.renderers.set(type, renderer);\n  }\n  \n  async render(content, container) {\n    const type = this.detectContentType(content);\n    const renderer = this.renderers.get(type);\n    \n    if (!renderer) {\n      throw new Error(`No renderer available for type: ${type}`);\n    }\n    \n    // キャッシュチェック\n    const cacheKey = this.generateCacheKey(content);\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n    \n    // 重複ロード防止\n    if (this.loadingTasks.has(cacheKey)) {\n      return await this.loadingTasks.get(cacheKey);\n    }\n    \n    // レンダリング実行\n    const renderPromise = renderer.render(content, container);\n    this.loadingTasks.set(cacheKey, renderPromise);\n    \n    try {\n      const result = await renderPromise;\n      this.cache.set(cacheKey, result);\n      return result;\n    } finally {\n      this.loadingTasks.delete(cacheKey);\n    }\n  }\n  \n  detectContentType(content) {\n    const ext = content.extension?.toLowerCase();\n    \n    switch (ext) {\n      case '.pdf': return 'pdf';\n      case '.png': case '.jpg': case '.jpeg': case '.gif': case '.webp': return 'image';\n      case '.svg': return 'svg';\n      case '.end': return 'end';
      case '.ends': return 'ends';\n      default:\n        // MIME type によるフォールバック判定\n        if (content.data) {\n          const uint8 = new Uint8Array(content.data.slice(0, 4));\n          if (uint8[0] === 0x25 && uint8[1] === 0x50 && uint8[2] === 0x44 && uint8[3] === 0x46) {\n            return 'pdf'; // %PDF\n          }\n          if (uint8[0] === 0x89 && uint8[1] === 0x50 && uint8[2] === 0x4E && uint8[3] === 0x47) {\n            return 'image'; // PNG\n          }\n        }\n        throw new Error(`Unknown content type: ${ext}`);\n    }\n  }\n  \n  generateCacheKey(content) {\n    return `${content.path}_${content.size}_${content.lastModified?.getTime()}`;\n  }\n  \n  clearCache() {\n    this.cache.clear();\n  }\n}\n```\n\n## 5. パネル管理システム\n\n### 5.1 パネルマネージャー (panel-manager.js)\n```javascript\nclass PanelManager {\n  constructor() {\n    this.panels = new Map();\n    this.layout = {\n      left: { visible: true, width: 300, minWidth: 200, maxWidth: 500 },\n      right: { visible: true, width: 350, minWidth: 250, maxWidth: 600 },\n      bottom: { visible: false, height: 200, minHeight: 150, maxHeight: 400 }\n    };\n    \n    this.setupPanels();\n    this.setupResizers();\n  }\n  \n  setupPanels() {\n    // 左パネル: エレメント管理\n    this.registerPanel('left', new ElementsPanel());\n    \n    // 右パネル: プロパティ\n    this.registerPanel('right', new PropertiesPanel());\n    \n    // 下パネル: ログ・ステータス\n    this.registerPanel('bottom', new LogPanel());\n    \n    this.updateLayout();\n  }\n  \n  registerPanel(position, panel) {\n    this.panels.set(position, panel);\n    panel.setPosition(position);\n    panel.onToggle((visible) => this.togglePanel(position, visible));\n  }\n  \n  togglePanel(position, visible = null) {\n    const layout = this.layout[position];\n    if (layout) {\n      layout.visible = visible !== null ? visible : !layout.visible;\n      this.updateLayout();\n      this.emit('layout:change', this.layout);\n    }\n  }\n  \n  resizePanel(position, size) {\n    const layout = this.layout[position];\n    if (!layout) return;\n    \n    const sizeKey = (position === 'bottom') ? 'height' : 'width';\n    const minKey = (position === 'bottom') ? 'minHeight' : 'minWidth';\n    const maxKey = (position === 'bottom') ? 'maxHeight' : 'maxWidth';\n    \n    layout[sizeKey] = Math.max(layout[minKey], Math.min(layout[maxKey], size));\n    this.updateLayout();\n  }\n  \n  updateLayout() {\n    const container = document.querySelector('.app-container');\n    \n    // CSS Grid レイアウト更新\n    const gridTemplate = this.generateGridTemplate();\n    container.style.gridTemplate = gridTemplate;\n    \n    // パネル要素の表示/非表示\n    Object.entries(this.layout).forEach(([position, config]) => {\n      const panel = document.querySelector(`.panel-${position}`);\n      if (panel) {\n        panel.style.display = config.visible ? 'block' : 'none';\n      }\n    });\n  }\n  \n  generateGridTemplate() {\n    const { left, right, bottom } = this.layout;\n    \n    let columns = [];\n    let rows = ['auto', '1fr'];\n    \n    // 列定義\n    if (left.visible) columns.push(`${left.width}px`);\n    columns.push('1fr');\n    if (right.visible) columns.push(`${right.width}px`);\n    \n    // 行定義（下パネルがある場合）\n    if (bottom.visible) {\n      rows = ['auto', '1fr', `${bottom.height}px`];\n    }\n    \n    return `\n      \"header header header\" ${rows[0]}\n      \"${left.visible ? 'left' : ''} main ${right.visible ? 'right' : ''}\" ${rows[1]}\n      ${bottom.visible ? `\"bottom bottom bottom\" ${rows[2]}` : ''}\n      / ${columns.join(' ')}\n    `;\n  }\n  \n  setupResizers() {\n    // リサイザーの設定とイベント処理\n    document.querySelectorAll('.panel-resizer').forEach(resizer => {\n      const position = resizer.dataset.position;\n      let startSize, startMouse;\n      \n      resizer.addEventListener('mousedown', (e) => {\n        startMouse = position === 'bottom' ? e.clientY : e.clientX;\n        startSize = this.layout[position][position === 'bottom' ? 'height' : 'width'];\n        \n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n        e.preventDefault();\n      });\n      \n      const handleMouseMove = (e) => {\n        const currentMouse = position === 'bottom' ? e.clientY : e.clientX;\n        const delta = currentMouse - startMouse;\n        \n        let newSize;\n        if (position === 'right') {\n          newSize = startSize - delta;\n        } else {\n          newSize = startSize + delta;\n        }\n        \n        this.resizePanel(position, newSize);\n      };\n      \n      const handleMouseUp = () => {\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n      };\n    });\n  }\n}\n```\n\n## 6. パフォーマンス最適化\n\n### 6.1 メモリ管理\n```javascript\nclass MemoryManager {\n  constructor() {\n    this.observers = new Set();\n    this.thresholds = {\n      warning: 500 * 1024 * 1024,  // 500MB\n      critical: 1024 * 1024 * 1024  // 1GB\n    };\n    \n    this.startMonitoring();\n  }\n  \n  startMonitoring() {\n    if ('memory' in performance) {\n      setInterval(() => {\n        const memInfo = performance.memory;\n        this.checkMemoryUsage(memInfo);\n      }, 10000); // 10秒間隔\n    }\n  }\n  \n  checkMemoryUsage(memInfo) {\n    const used = memInfo.usedJSHeapSize;\n    \n    if (used > this.thresholds.critical) {\n      this.emit('memory:critical', memInfo);\n      this.performGarbageCollection();\n    } else if (used > this.thresholds.warning) {\n      this.emit('memory:warning', memInfo);\n    }\n  }\n  \n  performGarbageCollection() {\n    // キャッシュクリア\n    if (window.contentRenderer) {\n      window.contentRenderer.clearCache();\n    }\n    \n    // 強制GC（Dev mode のみ）\n    if (window.gc && process.env.NODE_ENV === 'development') {\n      window.gc();\n    }\n  }\n}\n```\n\n### 6.2 レンダリング最適化\n```javascript\nclass RenderOptimizer {\n  constructor() {\n    this.renderQueue = [];\n    this.isRendering = false;\n    this.rafId = null;\n  }\n  \n  scheduleRender(task) {\n    this.renderQueue.push(task);\n    this.requestRender();\n  }\n  \n  requestRender() {\n    if (this.rafId === null) {\n      this.rafId = requestAnimationFrame(() => {\n        this.processRenderQueue();\n        this.rafId = null;\n      });\n    }\n  }\n  \n  processRenderQueue() {\n    if (this.isRendering) return;\n    \n    this.isRendering = true;\n    const start = performance.now();\n    \n    // 16ms以内で処理できるタスクのみ実行\n    while (this.renderQueue.length > 0 && (performance.now() - start) < 16) {\n      const task = this.renderQueue.shift();\n      try {\n        task();\n      } catch (error) {\n        console.error('Render task error:', error);\n      }\n    }\n    \n    this.isRendering = false;\n    \n    // まだタスクが残っている場合は次フレームで継続\n    if (this.renderQueue.length > 0) {\n      this.requestRender();\n    }\n  }\n}\n```\n\n## 7. デバッグ・ログシステム\n\n### 7.1 ログシステム (logger.js)\n```javascript\nclass Logger {\n  constructor() {\n    this.levels = {\n      ERROR: 0,\n      WARN: 1,\n      INFO: 2,\n      DEBUG: 3\n    };\n    \n    this.currentLevel = this.levels.INFO;\n    this.outputs = [new ConsoleOutput(), new FileOutput()];\n  }\n  \n  setLevel(level) {\n    if (typeof level === 'string') {\n      this.currentLevel = this.levels[level.toUpperCase()] ?? this.levels.INFO;\n    } else {\n      this.currentLevel = level;\n    }\n  }\n  \n  log(level, message, data = null) {\n    const numLevel = typeof level === 'string' ? this.levels[level.toUpperCase()] : level;\n    \n    if (numLevel <= this.currentLevel) {\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level: Object.keys(this.levels)[numLevel] || 'UNKNOWN',\n        message,\n        data,\n        stack: (new Error()).stack\n      };\n      \n      this.outputs.forEach(output => {\n        try {\n          output.write(logEntry);\n        } catch (error) {\n          console.error('Logger output error:', error);\n        }\n      });\n    }\n  }\n  \n  error(message, data) { this.log('ERROR', message, data); }\n  warn(message, data) { this.log('WARN', message, data); }\n  info(message, data) { this.log('INFO', message, data); }\n  debug(message, data) { this.log('DEBUG', message, data); }\n}\n\nclass ConsoleOutput {\n  write(logEntry) {\n    const color = this.getColor(logEntry.level);\n    const prefix = `[${logEntry.timestamp}] ${logEntry.level}:`;\n    \n    if (logEntry.data) {\n      console.log(`%c${prefix}`, `color: ${color}`, logEntry.message, logEntry.data);\n    } else {\n      console.log(`%c${prefix}`, `color: ${color}`, logEntry.message);\n    }\n  }\n  \n  getColor(level) {\n    switch (level) {\n      case 'ERROR': return '#ff5252';\n      case 'WARN': return '#ff9800';\n      case 'INFO': return '#2196f3';\n      case 'DEBUG': return '#9e9e9e';\n      default: return '#000000';\n    }\n  }\n}\n\n// グローバルロガー\nwindow.logger = new Logger();\n```\n\n## 8. 設定管理システム\n\n### 8.1 設定管理 (config.js)\n```javascript\nclass ConfigManager {\n  constructor() {\n    this.config = {};\n    this.defaultConfig = {\n      app: {\n        theme: 'light',\n        language: 'ja',\n        autoSave: true,\n        recentFilesLimit: 10\n      },\n      viewer: {\n        defaultZoom: 1.0,\n        zoomStep: 0.25,\n        smoothZoom: true,\n        centerOnLoad: true,\n        backgroundColor: '#f5f5f5'\n      },\n      panels: {\n        left: { visible: true, width: 300 },\n        right: { visible: true, width: 350 },\n        bottom: { visible: false, height: 200 }\n      },\n      performance: {\n        enableGPU: true,\n        maxCacheSize: 100 * 1024 * 1024, // 100MB\n        renderTimeout: 5000\n      }\n    };\n    \n    this.load();\n  }\n  \n  async load() {\n    try {\n      const stored = localStorage.getItem('engagedoc-config');\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        this.config = this.mergeConfig(this.defaultConfig, parsed);\n      } else {\n        this.config = { ...this.defaultConfig };\n      }\n    } catch (error) {\n      console.error('Failed to load config:', error);\n      this.config = { ...this.defaultConfig };\n    }\n  }\n  \n  async save() {\n    try {\n      localStorage.setItem('engagedoc-config', JSON.stringify(this.config));\n    } catch (error) {\n      console.error('Failed to save config:', error);\n    }\n  }\n  \n  get(path, defaultValue = undefined) {\n    return path.split('.').reduce((obj, key) => {\n      return obj?.[key];\n    }, this.config) ?? defaultValue;\n  }\n  \n  set(path, value) {\n    const keys = path.split('.');\n    const lastKey = keys.pop();\n    \n    const target = keys.reduce((obj, key) => {\n      if (!(key in obj)) obj[key] = {};\n      return obj[key];\n    }, this.config);\n    \n    target[lastKey] = value;\n    this.save();\n  }\n  \n  mergeConfig(defaults, user) {\n    const result = {};\n    \n    for (const [key, value] of Object.entries(defaults)) {\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        result[key] = this.mergeConfig(value, user[key] || {});\n      } else {\n        result[key] = user.hasOwnProperty(key) ? user[key] : value;\n      }\n    }\n    \n    return result;\n  }\n  \n  reset() {\n    this.config = { ...this.defaultConfig };\n    this.save();\n  }\n}\n\n// グローバル設定マネージャー\nwindow.config = new ConfigManager();\n```\n\n---\n\n## 9. 今後の拡張予定\n\n### v209での改善項目\n1. **TypeScript導入**: 型安全性の向上\n2. **WebAssembly統合**: パフォーマンス向上\n3. **Worker Threads**: バックグラウンド処理の最適化\n4. **Progressive Web App対応**: ウェブ版の提供\n5. **プラグインAPI拡張**: サードパーティ拡張の充実\n\n**技術仕様管理**: Media Viewer Development Team  \n**最終更新**: 2025-08-12  \n**仕様バージョン**: v208 → v209継承・拡張予定